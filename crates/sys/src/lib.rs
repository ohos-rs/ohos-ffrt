/* automatically generated by rust-bindgen 0.72.0 */

#![allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
#![allow(clippy::missing_safety_doc)]

#[link(name = "ffrt.z")]
unsafe extern "C" {}

pub type time_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[doc = " Should be distributed at once if possible, handle time equals to send time, prior to high level."]
pub const ffrt_queue_priority_t_ffrt_queue_priority_immediate: ffrt_queue_priority_t = 0;
#[doc = " High priority, sorted by handle time, prior to low level."]
pub const ffrt_queue_priority_t_ffrt_queue_priority_high: ffrt_queue_priority_t = 1;
#[doc = " Low priority, sorted by handle time, prior to idle level."]
pub const ffrt_queue_priority_t_ffrt_queue_priority_low: ffrt_queue_priority_t = 2;
#[doc = " Lowest priority, sorted by handle time, only distribute when there is no other level inside queue."]
pub const ffrt_queue_priority_t_ffrt_queue_priority_idle: ffrt_queue_priority_t = 3;
#[doc = " @brief Enumerates the task priority types.\n\n @since 12"]
pub type ffrt_queue_priority_t = ::std::os::raw::c_uint;
#[doc = " Inheritance."]
pub const ffrt_qos_default_t_ffrt_qos_inherit: ffrt_qos_default_t = -1;
#[doc = " Background task."]
pub const ffrt_qos_default_t_ffrt_qos_background: ffrt_qos_default_t = 0;
#[doc = " Real-time tool."]
pub const ffrt_qos_default_t_ffrt_qos_utility: ffrt_qos_default_t = 1;
#[doc = " Default type."]
pub const ffrt_qos_default_t_ffrt_qos_default: ffrt_qos_default_t = 2;
#[doc = " User initiated."]
pub const ffrt_qos_default_t_ffrt_qos_user_initiated: ffrt_qos_default_t = 3;
#[doc = " @brief Enumerates the task QoS types.\n\n @since 10"]
pub type ffrt_qos_default_t = ::std::os::raw::c_int;
#[doc = " @brief Defines the QoS type.\n\n @since 10"]
pub type ffrt_qos_t = ::std::os::raw::c_int;
#[doc = " @brief Defines the task function pointer type.\n\n @since 10"]
pub type ffrt_function_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[doc = " @brief Defines a task executor.\n\n @since 10"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ffrt_function_header_t {
    #[doc = " Function used to execute a task."]
    pub exec: ffrt_function_t,
    #[doc = " Function used to destroy a task."]
    pub destroy: ffrt_function_t,
    #[doc = " Need to be set to 0."]
    pub reserve: [u64; 2usize],
}
#[doc = " Task attribute storage size."]
pub const ffrt_storage_size_t_ffrt_task_attr_storage_size: ffrt_storage_size_t = 128;
#[doc = " Task executor storage size."]
pub const ffrt_storage_size_t_ffrt_auto_managed_function_storage_size: ffrt_storage_size_t = 96;
#[doc = " Mutex storage size."]
pub const ffrt_storage_size_t_ffrt_mutex_storage_size: ffrt_storage_size_t = 64;
#[doc = " Condition variable storage size."]
pub const ffrt_storage_size_t_ffrt_cond_storage_size: ffrt_storage_size_t = 64;
#[doc = " Queue storage size."]
pub const ffrt_storage_size_t_ffrt_queue_attr_storage_size: ffrt_storage_size_t = 128;
#[cfg(feature = "api-18")]
#[doc = " Rwlock storage size.\n\n @since 18"]
pub const ffrt_storage_size_t_ffrt_rwlock_storage_size: ffrt_storage_size_t = 64;
pub const ffrt_storage_size_t_ffrt_fiber_storage_size: ffrt_storage_size_t = 22;
#[doc = " @brief Defines the storage size of multiple types of structs.\n\n @since 10"]
pub type ffrt_storage_size_t = ::std::os::raw::c_uint;
#[doc = " General task."]
pub const ffrt_function_kind_t_ffrt_function_kind_general: ffrt_function_kind_t = 0;
#[doc = " Queue task."]
pub const ffrt_function_kind_t_ffrt_function_kind_queue: ffrt_function_kind_t = 1;
#[doc = " @brief Enumerates the task types.\n\n @since 10"]
pub type ffrt_function_kind_t = ::std::os::raw::c_uint;
#[doc = " Data dependency type."]
pub const ffrt_dependence_type_t_ffrt_dependence_data: ffrt_dependence_type_t = 0;
#[doc = " Task dependency type."]
pub const ffrt_dependence_type_t_ffrt_dependence_task: ffrt_dependence_type_t = 1;
#[doc = " @brief Enumerates the dependency types.\n\n @since 10"]
pub type ffrt_dependence_type_t = ::std::os::raw::c_uint;
#[doc = " @brief Defines the dependency data structure.\n\n @since 10"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ffrt_dependence_t {
    #[doc = " Dependency type."]
    pub type_: ffrt_dependence_type_t,
    #[doc = " Dependency pointer."]
    pub ptr: *const ::std::os::raw::c_void,
}
#[doc = " @brief Defines the dependency structure.\n\n @since 10"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ffrt_deps_t {
    #[doc = " Number of dependencies."]
    pub len: u32,
    #[doc = " Dependency data."]
    pub items: *const ffrt_dependence_t,
}
#[doc = " @brief Defines the task attribute structure.\n\n @since 10"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ffrt_task_attr_t {
    #[doc = " An array of uint32_t used to store the task attribute."]
    pub storage: [u32; 32usize],
}
#[doc = " @brief Defines the queue attribute structure.\n\n @since 10"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ffrt_queue_attr_t {
    #[doc = " An array of uint32_t used to store the queue attribute."]
    pub storage: [u32; 32usize],
}
#[doc = " @brief Defines the task handle, which identifies different tasks.\n\n @since 10"]
pub type ffrt_task_handle_t = *mut ::std::os::raw::c_void;
#[doc = " A generic error."]
pub const ffrt_error_t_ffrt_error: ffrt_error_t = -1;
#[doc = " Success."]
pub const ffrt_error_t_ffrt_success: ffrt_error_t = 0;
#[doc = " An out of memory error."]
pub const ffrt_error_t_ffrt_error_nomem: ffrt_error_t = 12;
#[doc = " A timeout error."]
pub const ffrt_error_t_ffrt_error_timedout: ffrt_error_t = 110;
#[doc = " A busy error."]
pub const ffrt_error_t_ffrt_error_busy: ffrt_error_t = 16;
#[doc = " A invalid value error."]
pub const ffrt_error_t_ffrt_error_inval: ffrt_error_t = 22;
#[doc = " @brief Enumerates the ffrt error codes.\n\n @since 10"]
pub type ffrt_error_t = ::std::os::raw::c_int;
#[doc = " @brief Defines the condition variable attribute structure.\n\n @since 10"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ffrt_condattr_t {
    #[doc = " A long integer used to store the condition variable attribute."]
    pub storage: ::std::os::raw::c_long,
}
#[doc = " @brief Defines the mutex attribute structure.\n\n @since 10"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ffrt_mutexattr_t {
    #[doc = " A long integer used to store the mutex attribute."]
    pub storage: ::std::os::raw::c_long,
}
#[cfg(feature = "api-18")]
#[doc = " @brief Defines the rwlock attribute structure.\n\n @since 18"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ffrt_rwlockattr_t {
    #[doc = " A long integer used to store the rwlock attribute."]
    pub storage: ::std::os::raw::c_long,
}
#[doc = " Normal mutex type."]
pub const ffrt_mutex_type_ffrt_mutex_normal: ffrt_mutex_type = 0;
#[doc = " Recursive mutex type."]
pub const ffrt_mutex_type_ffrt_mutex_recursive: ffrt_mutex_type = 2;
#[doc = " Default mutex type."]
pub const ffrt_mutex_type_ffrt_mutex_default: ffrt_mutex_type = 0;
#[doc = " @brief Enumerates the mutex types.\n\n Describes the mutex type, ffrt_mutex_normal is normal mutex;\n ffrt_mutex_recursive is recursive mutex, ffrt_mutex_default is normal mutex.\n\n @since 12"]
pub type ffrt_mutex_type = ::std::os::raw::c_uint;
#[doc = " @brief Defines the mutex structure.\n\n @since 10"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ffrt_mutex_t {
    #[doc = " An array of uint32_t used to store the mutex."]
    pub storage: [u32; 16usize],
}
#[cfg(feature = "api-18")]
#[doc = " @brief Defines the rwlock structure.\n\n @since 18"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ffrt_rwlock_t {
    #[doc = " An array of uint32_t used to store the rwlock."]
    pub storage: [u32; 16usize],
}
#[doc = " @brief Defines the condition variable structure.\n\n @since 10"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ffrt_cond_t {
    #[doc = " An array of uint32_t used to store the condition variable."]
    pub storage: [u32; 16usize],
}
#[cfg(feature = "api-20")]
#[doc = " @brief Defines the fiber structure.\n\n @since 20"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ffrt_fiber_t {
    #[doc = " An array of uint32_t used to store the fiber."]
    pub storage: [usize; 22usize],
}
#[doc = " @brief Defines the poller callback function type.\n\n @since 12"]
pub type ffrt_poller_cb =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, event: u32)>;
#[doc = " @brief Defines the timer callback function type.\n\n @since 12"]
pub type ffrt_timer_cb =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>;
#[doc = " @brief Defines the timer handler.\n\n @since 12"]
pub type ffrt_timer_t = ::std::os::raw::c_int;
unsafe extern "C" {
    #[doc = " @brief Initializes a condition variable.\n\n @param cond Indicates a pointer to the condition variable.\n @param attr Indicates a pointer to the condition variable attribute.\n @return Returns <b>ffrt_success</b> if the condition variable is initialized;\nreturns <b>ffrt_error_inval</b> otherwise.\n @since 10"]
    pub fn ffrt_cond_init(
        cond: *mut ffrt_cond_t,
        attr: *const ffrt_condattr_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Unblocks at least one of the threads that are blocked on a condition variable.\n\n @param cond Indicates a pointer to the condition variable.\n @return Returns <b>ffrt_success</b> if the thread is unblocked;\nreturns <b>ffrt_error_inval</b> otherwise.\n @since 10"]
    pub fn ffrt_cond_signal(cond: *mut ffrt_cond_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Unblocks all threads currently blocked on a condition variable.\n\n @param cond Indicates a pointer to the condition variable.\n @return Returns <b>ffrt_success</b> if the threads are unblocked;\nreturns <b>ffrt_error_inval</b> otherwise.\n @since 10"]
    pub fn ffrt_cond_broadcast(cond: *mut ffrt_cond_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Blocks the calling thread.\n\n @param cond Indicates a pointer to the condition variable.\n @param mutex Indicates a pointer to the mutex.\n @return Returns <b>ffrt_success</b> if the thread is unblocked after being blocked;\nreturns <b>ffrt_error_inval</b> otherwise.\n @since 10"]
    pub fn ffrt_cond_wait(
        cond: *mut ffrt_cond_t,
        mutex: *mut ffrt_mutex_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Blocks the calling thread for a given duration.\n\n If <b>ffrt_cond_signal</b> or <b>ffrt_cond_broadcast</b> is not called to unblock the thread\n when the maximum duration reaches, the thread is automatically unblocked.\n\n @param cond Indicates a pointer to the condition variable.\n @param mutex Indicates a pointer to the mutex.\n @param time_point Indicates the maximum duration that the thread is blocked.\n @return Returns <b>ffrt_success</b> if the thread is unblocked after being blocked;\nreturns <b>ffrt_error_timedout</b> if the maximum duration reaches;\nreturns <b>ffrt_error_inval</b> if the blocking fails.\n @since 10"]
    pub fn ffrt_cond_timedwait(
        cond: *mut ffrt_cond_t,
        mutex: *mut ffrt_mutex_t,
        time_point: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Destroys a condition variable, the user needs to invoke this interface.\n\n @param cond Indicates a pointer to the condition variable.\n @return Returns <b>ffrt_success</b> if the condition variable is destroyed;\nreturns <b>ffrt_error_inval</b> otherwise.\n @since 10"]
    pub fn ffrt_cond_destroy(cond: *mut ffrt_cond_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Initializes a fiber.\n\n This function initializes a fiber structure, preparing it for execution.\n\n @param fiber Indicates the pointer to the fiber structure to be initialized.\n @param func Indicates the entry point function that the fiber will execute.\n @param arg Indicates the argument to be passed to the entry point function.\n @param stack Indicates the pointer to the memory region to be used as the fiber's stack.\n @param stack_size Indicates the size of the stack in bytes.\n @return Returns <b>ffrt_success</b> if the fiber is initialized;\nreturns <b>ffrt_error</b> otherwise.\n @since 20"]
    pub fn ffrt_fiber_init(
        fiber: *mut ffrt_fiber_t,
        func: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        arg: *mut ::std::os::raw::c_void,
        stack: *mut ::std::os::raw::c_void,
        stack_size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Switch execution context between two fibers.\n\n Switches the execution context by saving the current context into the fiber specified\n by @c from and restoring the context from the fiber specified by @c to.\n\n @param from Indicates the pointer to the fiber into which the current context will be saved.\n @param to Indicates the pointer to the fiber from which the context will be restored.\n @since 20"]
    pub fn ffrt_fiber_switch(from: *mut ffrt_fiber_t, to: *mut ffrt_fiber_t);
}
#[doc = " Serial queue."]
pub const ffrt_queue_type_t_ffrt_queue_serial: ffrt_queue_type_t = 0;
#[doc = " Concurrent queue."]
pub const ffrt_queue_type_t_ffrt_queue_concurrent: ffrt_queue_type_t = 1;
#[doc = " Invalid queue."]
pub const ffrt_queue_type_t_ffrt_queue_max: ffrt_queue_type_t = 2;
#[doc = " @brief Enumerates the queue types.\n\n @since 12"]
pub type ffrt_queue_type_t = ::std::os::raw::c_uint;
#[doc = " @brief Defines the queue handle, which identifies different queues.\n\n @since 10"]
pub type ffrt_queue_t = *mut ::std::os::raw::c_void;
unsafe extern "C" {
    #[doc = " @brief Initializes a queue attribute.\n\n @param attr Indicates a pointer to the queue attribute.\n @return Returns <b>0</b> if the queue attribute is initialized;\nreturns <b>-1</b> otherwise.\n @since 10"]
    pub fn ffrt_queue_attr_init(attr: *mut ffrt_queue_attr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Destroys a queue attribute, the user needs to invoke this interface.\n\n @param attr Indicates a pointer to the queue attribute.\n @since 10"]
    pub fn ffrt_queue_attr_destroy(attr: *mut ffrt_queue_attr_t);
}
unsafe extern "C" {
    #[doc = " @brief Sets the QoS for a queue attribute.\n\n @param attr Indicates a pointer to the queue attribute.\n @param qos Indicates the QoS.\n @since 10"]
    pub fn ffrt_queue_attr_set_qos(attr: *mut ffrt_queue_attr_t, qos: ffrt_qos_t);
}
unsafe extern "C" {
    #[doc = " @brief Gets the QoS of a queue attribute.\n\n @param attr Indicates a pointer to the queue attribute.\n @return Returns the QoS.\n @since 10"]
    pub fn ffrt_queue_attr_get_qos(attr: *const ffrt_queue_attr_t) -> ffrt_qos_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets the execution timeout of a serial queue attribute.\n\n The lower limit of timeout value is 1 ms, if the value is less than 1 ms, it will be set to 1 ms.\n\n @param attr Serial queue attribute pointer.\n @param timeout_us Serial queue task execution timeout.\n @since 10"]
    pub fn ffrt_queue_attr_set_timeout(attr: *mut ffrt_queue_attr_t, timeout_us: u64);
}
unsafe extern "C" {
    #[doc = " @brief Gets the execution timeout of a serial queue attribute.\n\n @param attr Serial queue attribute pointer.\n @return Returns the serial queue task execution timeout.\n @since 10"]
    pub fn ffrt_queue_attr_get_timeout(attr: *const ffrt_queue_attr_t) -> u64;
}
unsafe extern "C" {
    #[doc = " @brief Sets the timeout callback function of a serial queue attribute.\n\n @warning Do not call `exit` in `f` - this my cause unexpected behavior.\n @param attr Serial queue attribute pointer.\n @param f Serial queue timeout callback function.\n @since 10"]
    pub fn ffrt_queue_attr_set_callback(
        attr: *mut ffrt_queue_attr_t,
        f: *mut ffrt_function_header_t,
    );
}
unsafe extern "C" {
    #[doc = " @brief Gets the timeout callback function of a serial queue attribute.\n\n @param attr Serial queue attribute pointer.\n @return Returns the serial queue task timeout callback function.\n @since 10"]
    pub fn ffrt_queue_attr_get_callback(
        attr: *const ffrt_queue_attr_t,
    ) -> *mut ffrt_function_header_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets the queue max concurrency of a queue attribute.\n\n @param attr Queue attribute pointer.\n @param max_concurrency queue max_concurrency.\n @since 12"]
    pub fn ffrt_queue_attr_set_max_concurrency(
        attr: *mut ffrt_queue_attr_t,
        max_concurrency: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @brief Gets the queue max concurrency of a queue attribute.\n\n @param attr Queue attribute pointer.\n @return Returns the queue max concurrency.\n @since 12"]
    pub fn ffrt_queue_attr_get_max_concurrency(
        attr: *const ffrt_queue_attr_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Sets the execution mode of a queue attribute.\n\n This interface specifies whether tasks in the queue are executed in coroutine mode or thread mode.\n By default, tasks are executed in coroutine mode.\n Set <b>mode</b> to <b>true</b> to enable thread-based execution.\n\n @param attr Queue attribute pointer.\n @param mode Indicates whether to enable thread-based execution mode.\n           - <b>true</b>: Tasks are executed as native threads (thread mode).\n           - <b>false</b>: Tasks are executed as coroutines (default).\n @since 20"]
    pub fn ffrt_queue_attr_set_thread_mode(attr: *mut ffrt_queue_attr_t, mode: bool);
}
unsafe extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Gets the execution mode of a queue attribute.\n\n This interface returns whether tasks in the queue are configured to run in thread-based execution mode (thread mode).\n\n @param attr Queue attribute pointer.\n @return Returns <b>true</b> if tasks are executed as native threads (thread mode);\n         returns <b>false</b> if tasks are executed as coroutines (default).\n @since 20"]
    pub fn ffrt_queue_attr_get_thread_mode(attr: *const ffrt_queue_attr_t) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Creates a queue.\n\n @param type Indicates the queue type.\n @param name Indicates a pointer to the queue name.\n @param attr Indicates a pointer to the queue attribute.\n @return Returns a non-null queue handle if the queue is created;\nreturns a null pointer otherwise.\n @since 10"]
    pub fn ffrt_queue_create(
        type_: ffrt_queue_type_t,
        name: *const ::std::os::raw::c_char,
        attr: *const ffrt_queue_attr_t,
    ) -> ffrt_queue_t;
}
unsafe extern "C" {
    #[doc = " @brief Destroys a queue, the user needs to invoke this interface.\n\n @param queue Indicates a queue handle.\n @since 10"]
    pub fn ffrt_queue_destroy(queue: ffrt_queue_t);
}
unsafe extern "C" {
    #[doc = " @brief Submits a task to a queue.\n\n @param queue Indicates a queue handle.\n @param f Indicates a pointer to the task executor.\n @param attr Indicates a pointer to the task attribute.\n @since 10"]
    pub fn ffrt_queue_submit(
        queue: ffrt_queue_t,
        f: *mut ffrt_function_header_t,
        attr: *const ffrt_task_attr_t,
    );
}
unsafe extern "C" {
    #[doc = " @brief Submits a task to the queue, and obtains a task handle.\n\n @param queue Indicates a queue handle.\n @param f Indicates a pointer to the task executor.\n @param attr Indicates a pointer to the task attribute.\n @return Returns a non-null task handle if the task is submitted;\nreturns a null pointer otherwise.\n @since 10"]
    pub fn ffrt_queue_submit_h(
        queue: ffrt_queue_t,
        f: *mut ffrt_function_header_t,
        attr: *const ffrt_task_attr_t,
    ) -> ffrt_task_handle_t;
}
unsafe extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Submits a task to a queue, simplified from of the ffrt_queue_submit interface.\n\n This interface wraps the provided task function and its argument into a task wrapper designed\n for queue submission (ffrt_function_kind_queue). The task destroy callback (after_func), which\n would normally handle any post-execution cleanup, is automatically set to NULL in this wrapper,\n thus omitting any additional cleanup actions. The resulting task wrapper is then submitted to\n the specified queue via the ffrt_queue_submit interface.\n\n @param queue Indicates a queue handle.\n @param func Indicates a task function to be executed.\n @param arg Indicates a pointer to the argument or closure data that will be passed to the task function.\n @param attr Indicates a pointer to the task attribute.\n @see ffrt_queue_submit\n @since 20"]
    pub fn ffrt_queue_submit_f(
        queue: ffrt_queue_t,
        func: ffrt_function_t,
        arg: *mut ::std::os::raw::c_void,
        attr: *const ffrt_task_attr_t,
    );
}
unsafe extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Submits a task to a queue, and obtains a task handle, simplified from the ffrt_queue_submit_h interface.\n\n This interface wraps the provided task function and its argument into a task wrapper designed\n for queue submission (ffrt_function_kind_queue). The task destroy callback (after_func), which\n would normally handle any post-execution cleanup, is automatically set to NULL in this wrapper,\n thus omitting any additional cleanup actions. The resulting task wrapper is then submitted to\n the specified queue via the ffrt_queue_submit_h interface.\n\n @param queue Indicates a queue handle.\n @param func Indicates a task function to be executed.\n @param arg Indicates a pointer to the argument or closure data that will be passed to the task function.\n @param attr Indicates a pointer to the task attribute.\n @return Returns a non-null task handle if the task is submitted;\nreturns a null pointer otherwise.\n @see ffrt_queue_submit_h\n @since 20"]
    pub fn ffrt_queue_submit_h_f(
        queue: ffrt_queue_t,
        func: ffrt_function_t,
        arg: *mut ::std::os::raw::c_void,
        attr: *const ffrt_task_attr_t,
    ) -> ffrt_task_handle_t;
}
unsafe extern "C" {
    #[doc = " @brief Waits until a task in the queue is complete.\n\n @param handle Indicates a task handle.\n @since 10"]
    pub fn ffrt_queue_wait(handle: ffrt_task_handle_t);
}
unsafe extern "C" {
    #[doc = " @brief Cancels a task in the queue.\n\n @param handle Indicates a task handle.\n @return Returns <b>0</b> if the task is canceled;\nreturns <b>-1</b> otherwise.\n @since 10"]
    pub fn ffrt_queue_cancel(handle: ffrt_task_handle_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Gets the application main thread queue.\n\n @return Returns application main thread queue.\n @since 12"]
    pub fn ffrt_get_main_queue() -> ffrt_queue_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets the application worker(ArkTs) thread queue.\n\n @return Returns application worker(ArkTs) thread queue.\n @deprecated since 18\n @since 12"]
    pub fn ffrt_get_current_queue() -> ffrt_queue_t;
}
#[doc = " @brief Defines the loop handle, which identifies different loops.\n\n @since 12"]
pub type ffrt_loop_t = *mut ::std::os::raw::c_void;
unsafe extern "C" {
    #[doc = " @brief Creates a loop.\n\n @param queue Indicates a queue.\n @return Returns a non-null loop handle if the loop is created;\nreturns a null pointer otherwise.\n @since 12"]
    pub fn ffrt_loop_create(queue: ffrt_queue_t) -> ffrt_loop_t;
}
unsafe extern "C" {
    #[doc = " @brief Destroys a loop, the user needs to invoke this interface.\n\n @param loop Indicates a loop handle.\n @return Returns 0 if the loop is destroyed;\nreturns -1 otherwise.\n @since 12"]
    pub fn ffrt_loop_destroy(loop_: ffrt_loop_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Starts a loop run.\n\n @param loop Indicates a loop handle.\n @return Returns -1 if loop run fail;\nreturns 0 otherwise.\n @since 12"]
    pub fn ffrt_loop_run(loop_: ffrt_loop_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Stops a loop run.\n\n @param loop Indicates a loop handle.\n @since 12"]
    pub fn ffrt_loop_stop(loop_: ffrt_loop_t);
}
unsafe extern "C" {
    #[doc = " @brief Controls an epoll file descriptor on ffrt loop.\n\n @warning Do not call `exit` in `cb` - this my cause unexpected behavior.\n\n @param loop Indicates a loop handle.\n @param op Indicates operation on the target file descriptor.\n @param fd Indicates the target file descriptor on which to perform the operation.\n @param events Indicates the event type associated with the target file descriptor.\n @param data Indicates user data used in cb.\n @param cb Indicates user cb which will be executed when the target fd is polled.\n @return Returns 0 if success;\nreturns -1 otherwise.\n @since 12"]
    pub fn ffrt_loop_epoll_ctl(
        loop_: ffrt_loop_t,
        op: ::std::os::raw::c_int,
        fd: ::std::os::raw::c_int,
        events: u32,
        data: *mut ::std::os::raw::c_void,
        cb: ffrt_poller_cb,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Starts a timer on ffrt loop.\n\n @warning Do not call `exit` in `cb` - this my cause unexpected behavior.\n @param loop Indicates a loop handle.\n @param timeout Indicates the number of milliseconds that specifies timeout.\n @param data Indicates user data used in cb.\n @param cb Indicates user cb which will be executed when timeout.\n @param repeat Indicates whether to repeat this timer.\n @return Returns a timer handle.\n @since 12"]
    pub fn ffrt_loop_timer_start(
        loop_: ffrt_loop_t,
        timeout: u64,
        data: *mut ::std::os::raw::c_void,
        cb: ffrt_timer_cb,
        repeat: bool,
    ) -> ffrt_timer_t;
}
unsafe extern "C" {
    #[doc = " @brief Stops a timer on ffrt loop.\n\n @param loop Indicates a loop handle.\n @param handle Indicates the target timer handle.\n @return Returns 0 if success;\nreturns -1 otherwise.\n @since 12"]
    pub fn ffrt_loop_timer_stop(loop_: ffrt_loop_t, handle: ffrt_timer_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Initializes a mutex attribute.\n\n @param attr Indicates a pointer to the mutex attribute.\n @return Returns <b>ffrt_success</b> if the mutex attribute is initialized;\nreturns <b>ffrt_error_inval</b> otherwise.\n @since 12"]
    pub fn ffrt_mutexattr_init(attr: *mut ffrt_mutexattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Sets the type of a mutex attribute.\n\n @param attr Indicates a pointer to the mutex attribute.\n @param type Indicates a int to the mutex type.\n @return Returns <b>ffrt_success</b> if the mutex attribute type is set successfully;\nreturns <b>ffrt_error_inval</b> if <b>attr</b> is a null pointer or\nthe mutex attribute type is not <b>ffrt_mutex_normal</b> or <b>ffrt_mutex_recursive</b>.\n @since 12"]
    pub fn ffrt_mutexattr_settype(
        attr: *mut ffrt_mutexattr_t,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Gets the type of a mutex attribute.\n\n @param attr Indicates a pointer to the mutex attribute.\n @param type Indicates a pointer to the mutex type.\n @return Returns <b>ffrt_success</b> if the mutex attribute type is get successfully;\nreturns <b>ffrt_error_inval</b> if <b>attr</b> or <b>type</b> is a null pointer.\n @since 12"]
    pub fn ffrt_mutexattr_gettype(
        attr: *mut ffrt_mutexattr_t,
        type_: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Destroys a mutex attribute, the user needs to invoke this interface.\n\n @param attr Indicates a pointer to the mutex attribute.\n @return Returns <b>ffrt_success</b> if the mutex attribute is destroyed;\nreturns <b>ffrt_error_inval</b> otherwise.\n @since 12"]
    pub fn ffrt_mutexattr_destroy(attr: *mut ffrt_mutexattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Initializes a mutex.\n\n @param mutex Indicates a pointer to the mutex.\n @param attr Indicates a pointer to the mutex attribute.\n @return Returns <b>ffrt_success</b> if the mutex is initialized;\nreturns <b>ffrt_error_inval</b> otherwise.\n @since 10"]
    pub fn ffrt_mutex_init(
        mutex: *mut ffrt_mutex_t,
        attr: *const ffrt_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Locks a mutex.\n\n @param mutex Indicates a pointer to the mutex.\n @return Returns <b>ffrt_success</b> if the mutex is locked;\nreturns <b>ffrt_error_inval</b> or blocks the calling thread otherwise.\n @since 10"]
    pub fn ffrt_mutex_lock(mutex: *mut ffrt_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Unlocks a mutex.\n\n @param mutex Indicates a pointer to the mutex.\n @return Returns <b>ffrt_success</b> if the mutex is unlocked;\nreturns <b>ffrt_error_inval</b> otherwise.\n @since 10"]
    pub fn ffrt_mutex_unlock(mutex: *mut ffrt_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Attempts to lock a mutex.\n\n @param mutex Indicates a pointer to the mutex.\n @return Returns <b>ffrt_success</b> if the mutex is locked;\nreturns <b>ffrt_error_inval</b> or <b>ffrt_error_busy</b> otherwise.\n @since 10"]
    pub fn ffrt_mutex_trylock(mutex: *mut ffrt_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Destroys a mutex, the user needs to invoke this interface.\n\n @param mutex Indicates a pointer to the mutex.\n @return Returns <b>ffrt_success</b> if the mutex is destroyed;\nreturns <b>ffrt_error_inval</b> otherwise.\n @since 10"]
    pub fn ffrt_mutex_destroy(mutex: *mut ffrt_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[cfg(feature = "api-18")]
    #[doc = " @brief Initializes a rwlock.\n\n @param rwlock Indicates a pointer to the rwlock.\n @param attr Indicates a pointer to the rwlock attribute.\n @return Returns <b>ffrt_success</b> if the rwlock is initialized;\nreturns <b>ffrt_error_inval</b> otherwise.\n @since 18"]
    pub fn ffrt_rwlock_init(
        rwlock: *mut ffrt_rwlock_t,
        attr: *const ffrt_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[cfg(feature = "api-18")]
    #[doc = " @brief Locks a write lock.\n\n @param rwlock Indicates a pointer to the rwlock.\n @return Returns <b>ffrt_success</b> if the rwlock is locked;\nreturns <b>ffrt_error_inval</b> or blocks the calling thread otherwise.\n @since 18"]
    pub fn ffrt_rwlock_wrlock(rwlock: *mut ffrt_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[cfg(feature = "api-18")]
    #[doc = " @brief Attempts to lock a write lock.\n\n @param rwlock Indicates a pointer to the rwlock.\n @return Returns <b>ffrt_success</b> if the rwlock is locked;\nreturns <b>ffrt_error_inval</b> or <b>ffrt_error_busy</b> otherwise.\n @since 18"]
    pub fn ffrt_rwlock_trywrlock(rwlock: *mut ffrt_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[cfg(feature = "api-18")]
    #[doc = " @brief Locks a read lock.\n\n @param rwlock Indicates a pointer to the rwlock.\n @return Returns <b>ffrt_success</b> if the rwlock is locked;\nreturns <b>ffrt_error_inval</b> or blocks the calling thread otherwise.\n @since 18"]
    pub fn ffrt_rwlock_rdlock(rwlock: *mut ffrt_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[cfg(feature = "api-18")]
    #[doc = " @brief Attempts to lock a read lock.\n\n @param rwlock Indicates a pointer to the rwlock.\n @return Returns <b>ffrt_success</b> if the rwlock is locked;\nreturns <b>ffrt_error_inval</b> or <b>ffrt_error_busy</b> otherwise.\n @since 18"]
    pub fn ffrt_rwlock_tryrdlock(rwlock: *mut ffrt_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[cfg(feature = "api-18")]
    #[doc = " @brief Unlocks a rwlock.\n\n @param rwlock Indicates a pointer to the rwlock.\n @return Returns <b>ffrt_success</b> if the rwlock is unlocked;\nreturns <b>ffrt_error_inval</b> otherwise.\n @since 18"]
    pub fn ffrt_rwlock_unlock(rwlock: *mut ffrt_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[cfg(feature = "api-18")]
    #[doc = " @brief Destroys a rwlock.\n\n @param rwlock Indicates a pointer to the rwlock.\n @return Returns <b>ffrt_success</b> if the rwlock is destroyed;\nreturns <b>ffrt_error_inval</b> otherwise.\n @since 18"]
    pub fn ffrt_rwlock_destroy(rwlock: *mut ffrt_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Suspends the calling thread for a given duration.\n\n @param usec Indicates the duration that the calling thread is suspended, in microseconds.\n @return Returns <b>ffrt_success</b> if the thread is suspended;\nreturns <b>ffrt_error</b> otherwise.\n @since 10"]
    pub fn ffrt_usleep(usec: u64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Passes control to other tasks so that they can be executed.\n\n @since 10"]
    pub fn ffrt_yield();
}
unsafe extern "C" {
    #[doc = " @brief Initializes a task attribute.\n\n @param attr Indicates a pointer to the task attribute.\n @return Returns <b>0</b> if the task attribute is initialized;\nreturns <b>-1</b> otherwise.\n @since 10"]
    pub fn ffrt_task_attr_init(attr: *mut ffrt_task_attr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Sets the name of a task attribute.\n\n @param attr Indicates a pointer to the task attribute.\n @param name Indicates a pointer to the task name.\n @since 10"]
    pub fn ffrt_task_attr_set_name(
        attr: *mut ffrt_task_attr_t,
        name: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " @brief Gets the name of a task attribute.\n\n @param attr Indicates a pointer to the task attribute.\n @return Returns a non-null pointer to the task name if the name is obtained;\nreturns a null pointer otherwise.\n @since 10"]
    pub fn ffrt_task_attr_get_name(attr: *const ffrt_task_attr_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Destroys a task attribute, the user needs to invoke this interface.\n\n @param attr Indicates a pointer to the task attribute.\n @since 10"]
    pub fn ffrt_task_attr_destroy(attr: *mut ffrt_task_attr_t);
}
unsafe extern "C" {
    #[doc = " @brief Sets the QoS of a task attribute.\n\n @param attr Indicates a pointer to the task attribute.\n @param qos Indicates the QoS.\n @since 10"]
    pub fn ffrt_task_attr_set_qos(attr: *mut ffrt_task_attr_t, qos: ffrt_qos_t);
}
unsafe extern "C" {
    #[doc = " @brief Gets the QoS of a task attribute.\n\n @param attr Indicates a pointer to the task attribute.\n @return Returns the QoS, which is <b>ffrt_qos_default</b> by default.\n @since 10"]
    pub fn ffrt_task_attr_get_qos(attr: *const ffrt_task_attr_t) -> ffrt_qos_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets the delay time of a task attribute.\n\n @param attr Indicates a pointer to the task attribute.\n @param delay_us Indicates the delay time, in microseconds.\n @since 10"]
    pub fn ffrt_task_attr_set_delay(attr: *mut ffrt_task_attr_t, delay_us: u64);
}
unsafe extern "C" {
    #[doc = " @brief Gets the delay time of a task attribute.\n\n @param attr Indicates a pointer to the task attribute.\n @return Returns the delay time.\n @since 10"]
    pub fn ffrt_task_attr_get_delay(attr: *const ffrt_task_attr_t) -> u64;
}
unsafe extern "C" {
    #[doc = " @brief Sets the priority of a task attribute.\n\n @param attr Indicates a pointer to the task attribute.\n @param priority Indicates the execute priority of concurrent queue task.\n @since 12"]
    pub fn ffrt_task_attr_set_queue_priority(
        attr: *mut ffrt_task_attr_t,
        priority: ffrt_queue_priority_t,
    );
}
unsafe extern "C" {
    #[doc = " @brief Gets the priority of a task attribute.\n\n @param attr Indicates a pointer to the task attribute.\n @return Returns the priority of concurrent queue task.\n @since 12"]
    pub fn ffrt_task_attr_get_queue_priority(
        attr: *const ffrt_task_attr_t,
    ) -> ffrt_queue_priority_t;
}
unsafe extern "C" {
    #[doc = " @brief Sets the stack size of a task attribute.\n\n @param attr Indicates a pointer to the task attribute.\n @param size Indicates the task stack size, unit is byte.\n @since 12"]
    pub fn ffrt_task_attr_set_stack_size(attr: *mut ffrt_task_attr_t, size: u64);
}
unsafe extern "C" {
    #[doc = " @brief Gets the stack size of a task attribute.\n\n @param attr Indicates a pointer to the task attribute.\n @return Returns the task stack size, unit is byte.\n @since 12"]
    pub fn ffrt_task_attr_get_stack_size(attr: *const ffrt_task_attr_t) -> u64;
}
unsafe extern "C" {
    #[doc = " @brief Updates the QoS of this task.\n\n @param qos Indicates the new QoS.\n @return Returns <b>0</b> if the QoS is updated;\nreturns <b>-1</b> otherwise.\n @since 10"]
    pub fn ffrt_this_task_update_qos(qos: ffrt_qos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Gets the QoS of this task.\n\n @return Returns the task qos.\n @since 12"]
    pub fn ffrt_this_task_get_qos() -> ffrt_qos_t;
}
unsafe extern "C" {
    #[doc = " @brief Gets the ID of this task.\n\n @return Returns the task ID.\n @since 10"]
    pub fn ffrt_this_task_get_id() -> u64;
}
unsafe extern "C" {
    #[doc = " @brief Applies memory for the function execution structure.\n\n @param kind Indicates the type of the function execution structure, which can be common or queue.\n @return Returns a non-null pointer if the memory is allocated;\nreturns a null pointer otherwise.\n @since 10"]
    pub fn ffrt_alloc_auto_managed_function_storage_base(
        kind: ffrt_function_kind_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " @brief Submits a task.\n\n @param f Indicates a pointer to the task executor.\n @param in_deps Indicates a pointer to the input dependencies.\n @param out_deps Indicates a pointer to the output dependencies.\n @param attr Indicates a pointer to the task attribute.\n @since 10"]
    pub fn ffrt_submit_base(
        f: *mut ffrt_function_header_t,
        in_deps: *const ffrt_deps_t,
        out_deps: *const ffrt_deps_t,
        attr: *const ffrt_task_attr_t,
    );
}
unsafe extern "C" {
    #[doc = " @brief Submits a task, and obtains a task handle.\n\n @param f Indicates a pointer to the task executor.\n @param in_deps Indicates a pointer to the input dependencies.\n @param out_deps Indicates a pointer to the output dependencies.\n @param attr Indicates a pointer to the task attribute.\n @return Returns a non-null task handle if the task is submitted;\nreturns a null pointer otherwise.\n @since 10"]
    pub fn ffrt_submit_h_base(
        f: *mut ffrt_function_header_t,
        in_deps: *const ffrt_deps_t,
        out_deps: *const ffrt_deps_t,
        attr: *const ffrt_task_attr_t,
    ) -> ffrt_task_handle_t;
}
unsafe extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Submits a task, simplified from the ffrt_submit_base interface.\n\n This interface wraps the provided task function and its argument into a task wrapper\n designated as a general task (ffrt_function_kind_general). During wrapper creation, the\n task destroy callback (after_func), which is intended to handle any post-execution cleanup,\n is simplified to NULL. The resulting task wrapper is then submitted using the underlying\n ffrt_submit_base interface.\n\n @param func Indicates a task function to be executed.\n @param arg Indicates a pointer to the argument or closure data that will be passed to the task function.\n @param in_deps Indicates a pointer to the input dependencies.\n @param out_deps Indicates a pointer to the output dependencies.\n @param attr Indicates a pointer to the task attribute.\n @see ffrt_submit_base\n @since 20"]
    pub fn ffrt_submit_f(
        func: ffrt_function_t,
        arg: *mut ::std::os::raw::c_void,
        in_deps: *const ffrt_deps_t,
        out_deps: *const ffrt_deps_t,
        attr: *const ffrt_task_attr_t,
    );
}
unsafe extern "C" {
    #[cfg(feature = "api-20")]
    #[doc = " @brief Submits a task, and obtains a task handle, simplified from the ffrt_submit_h_base interface.\n\n This interface wraps the provided task function and its argument into a task wrapper\n designated as a general task (ffrt_function_kind_general). During wrapper creation, the\n task destroy callback (after_func), which is intended to handle any post-execution cleanup,\n is simplified to NULL. The resulting task wrapper is then submitted using the underlying\n ffrt_submit_h_base interface.\n\n @param func Indicates a task function to be executed.\n @param arg Indicates a pointer to the argument or closure data that will be passed to the task function.\n @param in_deps Indicates a pointer to the input dependencies.\n @param out_deps Indicates a pointer to the output dependencies.\n @param attr Indicates a pointer to the task attribute.\n @return Returns a non-null task handle if the task is submitted;\nreturns a null pointer otherwise.\n @see ffrt_submit_h_base\n @since 20"]
    pub fn ffrt_submit_h_f(
        func: ffrt_function_t,
        arg: *mut ::std::os::raw::c_void,
        in_deps: *const ffrt_deps_t,
        out_deps: *const ffrt_deps_t,
        attr: *const ffrt_task_attr_t,
    ) -> ffrt_task_handle_t;
}
unsafe extern "C" {
    #[doc = " @brief Increases reference count of a task.\n\n @param handle Indicates a task handle.\n @return Returns the task handle original reference count.\n @since 12"]
    pub fn ffrt_task_handle_inc_ref(handle: ffrt_task_handle_t) -> u32;
}
unsafe extern "C" {
    #[doc = " @brief Decreases reference count of a task.\n\n @param handle Indicates a task handle.\n @return Returns the task handle original reference count.\n @since 12"]
    pub fn ffrt_task_handle_dec_ref(handle: ffrt_task_handle_t) -> u32;
}
unsafe extern "C" {
    #[doc = " @brief Destroys a task handle, the user needs to invoke this interface.\n\n @param handle Indicates a task handle.\n @since 10"]
    pub fn ffrt_task_handle_destroy(handle: ffrt_task_handle_t);
}
unsafe extern "C" {
    #[doc = " @brief Waits until the dependent tasks are complete.\n\n @param deps Indicates a pointer to the dependent tasks.\n @since 10"]
    pub fn ffrt_wait_deps(deps: *const ffrt_deps_t);
}
unsafe extern "C" {
    #[doc = " @brief Waits until all submitted tasks are complete.\n\n @since 10"]
    pub fn ffrt_wait();
}
unsafe extern "C" {
    #[doc = " @brief Starts a timer on ffrt worker\n\n @warning Do not call `exit` in `cb` - this my cause unexpected behavior.\n\n @param qos Indicates qos of the worker that runs timer.\n @param timeout Indicates the number of milliseconds that specifies timeout.\n @param data Indicates user data used in cb.\n @param cb Indicates user cb which will be executed when timeout.\n @param repeat Indicates whether to repeat this timer.\n @return Returns a timer handle.\n @since 12"]
    pub fn ffrt_timer_start(
        qos: ffrt_qos_t,
        timeout: u64,
        data: *mut ::std::os::raw::c_void,
        cb: ffrt_timer_cb,
        repeat: bool,
    ) -> ffrt_timer_t;
}
unsafe extern "C" {
    #[doc = " @brief Stops a timer on ffrt worker\n\n @param qos Indicates qos of the worker that runs timer.\n @param handle Indicates the target timer handle.\n @return Returns 0 if success;\nreturns -1 otherwise.\n @since 12"]
    pub fn ffrt_timer_stop(qos: ffrt_qos_t, handle: ffrt_timer_t) -> ::std::os::raw::c_int;
}
